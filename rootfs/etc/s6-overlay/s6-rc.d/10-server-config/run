#!/command/with-contenv bash
. "/usr/local/bin/logger"
. "/usr/local/bin/parse-ini"

if [[ -f "/etc/wireguard/wg0.conf" ]]; then
  exit 0
fi

if [[ -z "${LISTEN_PORT}" ]]; then
    # client mode
    exit 0
fi

if [[ -z "${ADDRESS}" ]]; then
    echo "Missing environment variables!" | error
    echo "LISTEN_PORT: ${LISTEN_PORT}, ADDRESS: ${ADDRESS}" | error
    echo "Exiting..." | error
    exit 1
fi

if [[ -z "${PRIVATE_KEY}" ]]; then
    if [[ -f /config/privkey.key ]]; then
        PRIVATE_KEY=$(cat /config/privkey.key)
    else
      echo "PRIVATE_KEY variable is missing!" | warn
      echo "Generating a new private key..." | warn
      PRIVATE_KEY=$(wg genkey)
      echo "Writing the private key to /config/privkey.key" | warn
      echo "${PRIVATE_KEY}" > /config/privkey.key
    fi
fi

{
  echo "[Interface]"
  echo "Address = ${ADDRESS}"
  echo "ListenPort = ${LISTEN_PORT}"
  echo "PrivateKey = ${PRIVATE_KEY}"
} > /run/wireguard/wg0.conf

server_public_key=$(echo "${PRIVATE_KEY}" | wg pubkey)


echo "Adding iptables rules..." | info
up_command=""
up_command+="iptables -A FORWARD -i wg0 -j ACCEPT;"
up_command+="iptables -A FORWARD -o wg0 -j ACCEPT;"
up_command+="iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE;"
up_command+="iptables -A INPUT -p udp --dport ${LISTEN_PORT} -j ACCEPT;"

down_command=${up_command//-A/-D}
if [[ "${DISABLE_IP6TABLES}" != "true" ]]; then
  echo "Adding ip6tables rules..." | info
  up_command+=${up_command//iptables/ip6tables}
  down_command+=${down_command//iptables/ip6tables}
fi


echo -n > /tmp/peers.conf

# Generate client config and peers for server
i=1
while true; do
    allowed_ip="ALLOWED_IP_${i}"
    allowed_ip=${!allowed_ip}
    if [[ -z "${allowed_ip}" ]]; then
        break
    fi

    value_generated=0
    public_key="PUBLIC_KEY_${i}"
    public_key=${!public_key}
    if [[ -z "${public_key}" ]]; then
        # try getting key from existing config file
        if [ -f "/config/client_${i}.conf" ]; then
            private_key=$(parse_ini "/config/client_${i}.conf" "Interface" "PrivateKey")
            if [[ -z "${private_key}" ]]; then
                echo "The client configuration for client ${i} was found but is missing a private key!" | error
                echo "Exiting..." | error
                exit 1
            fi
        else
            # generate new public key
            private_key=$(wg genkey)
            value_generated=1
        fi
        public_key=$(echo "${private_key}" | wg pubkey)
    fi

    psk="PRESHARED_KEY_${i}"
    psk=${!psk}
    if [[ -z "${psk}" ]]; then
        # try getting key from existing config file
        if [ -f "/config/client_${i}.conf" ]; then
            psk=$(parse_ini "/config/client_${i}.conf" "Peer" "PresharedKey")
            if [[ -z "${psk}" ]]; then
                echo "The client config exists but the PresharedKey is missing" | warn
                echo "Not using a PresharedKey for client ${i}!" | warn
            fi
        else
            # generate new preshared key
            psk=$(wg genpsk)
            value_generated=1
        fi
    fi

    persistent_keepalive="PERSISTENT_KEEP_ALIVE_${i}"
    persistent_keepalive=${!persistent_keepalive}
    if [[ -z "${persistent_keepalive}" ]]; then
        # try getting value from existing config file
        if [ -f "/config/client_${i}.conf" ]; then
            persistent_keepalive=$(parse_ini "/config/client_${i}.conf" "Peer" "PersistentKeepalive")
        fi
    fi

    dns="DNS_${i}"
    dns=${!dns}
    if [[ -z "${dns}" ]]; then
        # try getting value from existing config file
        if [ -f "/config/client_${i}.conf" ]; then
            dns=$(parse_ini "/config/client_${i}.conf" "Interface" "DNS")
        fi
    fi

    if [[ value_generated -eq 1 ]]; then
        endpoint="${ENDPOINT}"
        if [[ -z "${endpoint}" ]]; then
            endpoint="CHANGE_ME"
            echo "Endpoint not set!" | warn
            echo "Using a default value of ${endpoint} for peer ${i}'s endpoint!" | warn
            echo "You will need to change this to the correct address for your server" | warn
        fi

        echo "Generated new key for client ${i}:" | info
        {
            echo "[Interface]"
            echo "PrivateKey = ${private_key}"
            echo "Address = ${allowed_ip}"
            if [[ -n "${dns}" ]]; then
                echo "DNS = ${dns}"
            fi
            echo ""
            echo "[Peer]"
            echo "PublicKey = ${server_public_key}"
            echo "PresharedKey = ${psk}"
            echo "Endpoint = ${endpoint}:${LISTEN_PORT}"
            if [[ -n "${persistent_keepalive}" ]]; then
                echo "PersistentKeepalive = ${persistent_keepalive}"
            fi
            # Just hard code the allowed IPs for client configs
            echo "AllowedIPs = 0.0.0.0/0, ::/0"
        } > /config/client_${i}.conf
        qrencode -t ansiutf8 -l L < /config/client_${i}.conf
        if [[ ${VERBOSE} = "true" ]]; then
          echo "Generated client config for client ${i} is:" | info
          cat /config/client_${i}.conf
        fi
    fi

    {
        echo "# Client ${i}"
        echo "[Peer]"
        echo "PublicKey = ${public_key}"
        if [[ -n "${psk}" ]]; then
            echo "PresharedKey = ${psk}"
        fi
        echo "AllowedIPs = ${allowed_ip}"
        if [[ -n "${persistent_keepalive}" ]]; then
            echo "PersistentKeepalive = ${persistent_keepalive}"
        fi
        echo ""
    } >> /tmp/peers.conf

    # Generate port forwarding iptables commands
    # Start at 0 because we increment it on the first iteration
    port_fwd_num=0
    while true; do
        port_fwd_num=$((port_fwd_num + 1))

        port_fwd_port="PORT_FORWARD_PORT_${i}_${port_fwd_num}"
        port_fwd_port=${!port_fwd_port}
        if [[ -z "${port_fwd_port}" ]]; then
            break
        fi
        port_fwd_mode="PORT_FORWARD_MODE_${i}_${port_fwd_num}"
        port_fwd_mode=${!port_fwd_mode}
        if [[ -z "${port_fwd_mode}" ]]; then
            echo "Port forward mode not set for PORT_FORWARD_MODE_${i}_${port_fwd_num}" | error
            echo "Skipping port forward" | error
            continue
        elif [[ "${port_fwd_mode}" != "tcp" ]] && [[ "${port_fwd_mode}" != "udp" ]]; then
            echo "Port forward mode must be tcp or udp for PORT_FORWARD_MODE_${i}_${port_fwd_num}" | error
            echo "Skipping port forward" | error
            continue
        fi
        port_fwd_addr="PORT_FORWARD_ADDRESS_${i}_${port_fwd_num}"
        port_fwd_addr=${!port_fwd_addr}
        if [[ -z "${port_fwd_addr}" ]]; then
            echo "Port forward address not set for PORT_FORWARD_ADDRESS_${i}_${port_fwd_num}" | error
            echo "Skipping port forward" | error
            continue
        fi
        port_fwd_version="PORT_FORWARD_VERSION_${i}_${port_fwd_num}"
        port_fwd_version=${!port_fwd_version}
        if [[ -z "${port_fwd_version}" ]]; then
            echo "Port forward version not set for PORT_FORWARD_VERSION_${i}_${port_fwd_num}" | error
            echo "Skipping port forward" | error
            continue
        elif [[ "${port_fwd_version}" != "4" ]] && [[ "${port_fwd_version}" != "6" ]]; then
            echo "Port forward version must be 4 or 6 for PORT_FORWARD_VERSION_${i}_${port_fwd_num}" | error
            echo "Skipping port forward" | error
            continue
        fi

        iptables_cmd="iptables"
        if [[ "${port_fwd_version}" == "6" ]]; then
            iptables_cmd="ip6tables"
        fi
        iptables_cmd+=" -t nat -A PREROUTING -i eth0 -p ${port_fwd_mode} "
        iptables_cmd+="--dport ${port_fwd_port} -j DNAT --to-destination ${port_fwd_addr}"

        if [[ ${VERBOSE} = "true" ]]; then
          echo "Generated iptables command for PORT_FORWARD_PORT_${i}_${port_fwd_num} is:" | info
          echo "${iptables_cmd}" | info
        fi

        up_command+="${iptables_cmd};"
        down_command+="${iptables_cmd//-A/-D};"
    done

    i=$(( i+1 ))
done

{
  echo "PostUp = ${up_command}"
  echo "PostDown = ${down_command}"
  echo ""
} >> /run/wireguard/wg0.conf

cat /tmp/peers.conf >> /run/wireguard/wg0.conf
rm /tmp/peers.conf

if [[ ${VERBOSE} = "true" ]]; then
  echo "Generated configuration is: " | info
  info < /run/wireguard/wg0.conf
fi
